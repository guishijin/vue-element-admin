Nodejs的模块系统以及require的机制
一、简介

　　Nodejs 有一个简单的模块加载系统。在 Nodejs 中，文件和模块是一一对应的（每个文件被视为一个独立的模块），这个文件可能是 JavaScript 代码，JSON 或编译过的C/C++ 扩展，例如：

复制代码
/**
 *foo.js
 *将这个js文件导出为模块
 */
exports.hello = function() {
    console.log("hello Nodejs!");
}
复制代码


复制代码
/**
 *main.js
 *main.js和foo.js在同一目录下
 *在控制台中将会输出：hello Nodejs！
 */
var foo = require("./foo.js");

foo.hello();
复制代码


二、如何将模块导出—— module.exports 与 exports 的区别

　　Nodejs 中的每一个模块都会自动创建一个 module 对象，同时 module 对象下有一个叫 exports 的属性，可以将某个类的实例赋值给 module.exports，从而导出这个类的实例。在模块被执行前，Nodejs 会将 module.exports 的值赋于全局变量 exports ，以便 module.exports.f = ...  可以更简洁的写成 exports.f = ...  。注意：就像所有变量一样，如果重新给 exports 赋值，它就不再绑定到 module.exports 了，也不会导出指定模块

例如：

复制代码
/**
 *foo.js
 *导入方式：var foo = require("./foo.js");
 */
function Foo() {}
Foo.prototype.hello = function() {
    console.log("hello Nodejs!");
}

module.exports = new Foo();
复制代码


复制代码
/**
 *foo.js
 *导入方式：var Foo = require("./foo.js"); var foo = new Foo();
 */
function Foo() {}
Foo.prototype.hello = function() {
    console.log("hello Nodejs!");
}

module.exports = Foo;
复制代码


复制代码
/**
 *foo.js
 *导入方式：var foo = require("./foo.js");
 */
exports.hello = function() {
    console.log("hello Nodejs!");
}
复制代码


三、require的机制

　　假设Y是路径，X是文件名或目录名，当 Nodejs 遇到 require(Y+X) 时，按照下面的顺序处理：

　　1、如果 X 是核心模块（例如：require("http")）

　　a.返回该模块

　　b.不再继续执行

　　2、如果Y是以“./”、“/”或“../”开头

　　a.把X当成文件，从指定路径开始，依次查找下面文件：X、X.js、X.json、X.node，只要其中一个存在，就返回该文件，不再继续执行

　　b.把X当成目录，从指定路径开始，依次查找下面文件：X/package.json(main字段)、X/index.js、X/index.json、X/index.node，只要其中一个存在，就返回该文件，不再继续执行

　　3.如果 X 不是核心模块，也没有以“./”、“/”或“../”开头，则Nodejs会从当前模块的父目录开始，尝试从它的 /node_module 目录里加载模块，如果还是没有找到，则移动到再上一层父目录，直到文件系统的根目录

　　4.抛出“not found”
